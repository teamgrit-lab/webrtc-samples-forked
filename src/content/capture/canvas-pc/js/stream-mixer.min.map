{"version":3,"sources":["webpack://StreamMixer/webpack/universalModuleDefinition","webpack://StreamMixer/webpack/bootstrap","webpack://StreamMixer/./src/index.js","webpack://StreamMixer/./src/StreamMixer.Debugger.js","webpack://StreamMixer/./src/AudioMixer/AudioObject.js","webpack://StreamMixer/./src/AudioMixer/AudioMixer.js","webpack://StreamMixer/./src/VideoMixer/preset/POSITIONS.js","webpack://StreamMixer/./src/VideoMixer/VideoMixer.js","webpack://StreamMixer/./src/VideoMixer/VideoObject.js","webpack://StreamMixer/./src/StreamMixer.js","webpack://StreamMixer/./src/Module.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","console","log","default","StreamMixer_Debugger","_startTime","_videoState","videoMixer","videoElementList","droppedFrames","cTime","performance","now","cDebug","label","params","init","showObjectList","Frames","_lastExecuteTime","_lastFrameDelay","setLastExecuteTime","time","setLastFrameDelay","lastDrawTime","DroppedFrames","increase","show","div","AudioObject","[object Object]","id","source","sourceType","context","destination","mediaType","muted","_id","_source","_sourceType","_audioCtx","_destination","_mediaType","_muted","_sourceNode","createMediaStreamSource","createMediaElementSource","_gainNode","createGain","gain","filter","createBiquadFilter","geometricMean","Math","sqrt","frequency","Q","connect","disconnect","setValueAtTime","currentTime","AudioMixer","AudioContext","window","webkitAudioContext","audioCtx","createMediaStreamDestination","_isEnable","audioObjectList","addNoiseOscillator","oscillator","createOscillator","type","start","masterNode","aObj","push","idx","findIndex","val","splice","stream","getTracks","mute","setVolume","SCREEN","width","height","MARGIN","TOP","LEFT","RIGHT","BOTTOM","SIZE","SMALL","WIDTH","HEIGHT","PRESET_POSITION","FULL","top","left","LEFT_FULL","RIGHT_FULL","TOP_LEFT_SMALL","TOP_RIGHT_SMALL","getHorizontalRight","TOP_CENTER_SMALL","getHorizontalCenter","BOTTOM_LEFT_SMALL","getVerticalBottom","BOTTOM_RIGHT_SMALL","BOTTOM_CENTER_SMALL","objWidth","objHeight","FRAME_MIN_TIME","INTERVAL","MAX_FRAME_TIME","MIN_FRAME_TIME","lastFrameTime","VideoMixer_SIZE","MIN_WIDTH","MIN_HEIGHT","GUIDE","POINT_SIZE","LINE_WIDTH","LINE_COLOR","Z_INDEX_BUTTON_WIDTH","Z_INDEX_BUTTON_HEIGHT","Z_INDEX_BUTTON_COLOR","Z_INDEX_BUTTON_COLOR_UP","Z_INDEX_BUTTON_COLOR_DOWN","Z_INDEX_TEXT_FONT","Z_INDEX_TEXT_FONT_SIZE","Z_INDEX_TEXT_WIDTH","Z_INDEX_TEXT_HEIGHT","ARROW_WIDTH","ARROW_HEIGHT","ARROW_COLOR","MOUSE_BUTTON","NONE","CLICKED","SETTINGS","Z_INDEX_MIN","Z_INDEX_MAX","VideoMixer_VideoMixer","canvasElementID","previewVideoElementID","videoObjectList","videoObjectListAsc","optimizeDrawMode","mouseButtonState","initCanvas","vRatio","uiCanvas","offsetWidth","hRatio","offsetHeight","bindEventHandler","requestAnimStartTime","recursiveStartTime","then","Date","delta","document","querySelector","uiCanvasCtx","getContext","desynchronized","alpha","frontCanvas","createElement","frontCanvasCtx","OffscreenCanvas","bufferCanvas","bufferCanvasCtx","mixedStream","captureStream","setEnable","vObj","sortVideoObjectList","ascIdx","detachEventObject","requestAnimationFrame","draw","clearRect","fillStyle","fillRect","map","drawSource","getDrawSource","src","drawImage","mouseOverObject","isFullscreen","drawOutline","drawTriangle","drawZIndexButton","drawCalcDeltaTime","startTime","getVideoTracks","requestFrame","executeTime","nextFrameDelay","setTimeout","drawWithFps","milliseconds","drawWithoutFps","destObject","ctx","strokeStyle","lineWidth","strokeRect","parseInt","beginPath","x","y","moveTo","lineTo","closePath","fill","drawTopLeft","drawBottomRight","objTop","objRight","drawUpButton","color","drawDownButton","clickPosition","drawButtonBackground","drawUpArrow","drawDownArrow","captureFrame","canvas","sort","a","b","zIndex","createdAt","length","ondblclick","e","clickObj","findClickObject","hasSavedPosition","restorePosition","savePosition","ratio","setPosition","fullScreen","aspectRatio","calcWidth","calcHeight","onmousedown","button","clickObject","startPos","offsetX","offsetY","startObjectPos","bottom","right","onmouseover","onmouseout","onmousemove","detectMouseOut","style","cursor","moveX","moveY","moveX_inCanvas","calcUItoCanvasX","moveY_inCanvas","calcUItoCanvasY","resizeWidth","resizeHeight","onmouseup","onclick","objList","mouseX","mouseY","find","objLeft","objBottom","VideoObject_VideoObject","props","frameRate","autoSize","transparent","onended","enabled","_transparent","_enabled","_top","_left","_bottom","_right","_width","_height","_zIndex","_fullScreen","_frameRate","_createdAt","wScale","videoWidth","videoHeight","_offscreenCanvas","_offscreenCanvasCtx","autoDraw","posCenter","posMiddle","srcWidth","max","srcHeight","_savedPosition","_oldTop","_oldLeft","_oldBottom","_oldRight","_oldWidth","_oldHeight","_oldZIndex","_oldFullScreen","oldRight","values","undefined","outLine","onOff","_outline","StreamMixer","_videoElementList","_videoMixer","_audioMixer","_previewVideoID","_previewVideo","_outputStream","initPreviewVideo","getElementById","srcObject","play","findVideoItem","objID","k","generateID","random","toString","substr","initStream","async","MediaStream","forEach","track","addTrack","getAudioTracks","videoElementID","addMedia","video","audio","Promise","resolve","reject","videoEl","autoplay","load","crossOrigin","addVideoObject","getDestination","addAudioObject","catch","err","removeMedia","removeVideoObject","removeAudioObject","changeStream","item","getStream","enableCanvas","pause","getCurrentTime","setCurrentTime","getVideoObject","setDrawMode","Debug","__webpack_exports__"],"mappings":"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","file":"stream-mixer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StreamMixer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StreamMixer\"] = factory();\n\telse\n\t\troot[\"StreamMixer\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","console.log(\"%cStreamMixer 1.7.40\", 'font-weight: 700;')\nmodule.exports = require('./Module').default;","export default (function() {\n    let _startTime = null;\n    let _videoState = {\n        videoMixer: null,\n        videoElementList: 0,\n        droppedFrames: 0,\n    }\n\n    function cTime() {\n        console.log((`%c[START TIME]%c : ${_startTime}`),\n            // 'font-weight: 700;',\n            'font-weight: 700; color: white; background: orange;',\n            'font-weight: 400; background: none');\n        console.log((`%c[CURRENT TIME]%c : ${performance.now()}`),\n            // 'font-weight: 700;',\n            'font-weight: 700; color: white; background: orange;',\n            'font-weight: 400; background: none');\n    }\n\n    function cDebug(label, params) {\n        console.log(`%c[DEBUG]%c(${label}) : ${params}`,\n                    // 'font-weight: 700;',\n                    'font-weight: 700; color: white; background: green;',\n                    'font-weight: 400; background: none');\n    }\n\n    function init(videoElementList, videoMixer) {\n        _startTime = performance.now();\n        _videoState.videoMixer = videoMixer;\n        _videoState.videoElementList = videoElementList\n    }\n\n    function showObjectList() {\n        cDebug(\"ObjectList\", _videoState.videoElementList)\n    }\n\n    let Frames = (function(){\n        let _lastExecuteTime = 0;\n        let _lastFrameDelay = 0;\n        function setLastExecuteTime(time) {\n            _lastExecuteTime = time;\n        }\n        function setLastFrameDelay(time){\n            _lastFrameDelay = time;\n        }\n        function lastDrawTime() {\n            cTime();\n            cDebug(\"LastExecuteTime\", _lastExecuteTime);\n            cDebug(\"LastFrameDelay\", _lastFrameDelay);\n            cDebug(\"Total\", _lastExecuteTime + _lastFrameDelay);\n        }\n\n        return { setLastExecuteTime, setLastFrameDelay, lastDrawTime}\n    })()\n\n    let DroppedFrames = (function() {\n        function increase() {\n            _videoState.droppedFrames = _videoState.droppedFrames + 1;\n        }\n        function show() {\n            cTime();\n            cDebug(\"DroppedFrames\", _videoState.droppedFrames);\n            const div = (performance.now() - _startTime) / 1000\n            cDebug(\"DroppedFrames/s\", _videoState.droppedFrames / div);\n        }\n\n        return { increase, show }\n    })()\n\n    return {\n        init,\n        showObjectList,\n        Frames,\n        DroppedFrames\n    }\n})()","export const convertAudioStream = src => {\n    const stream = new MediaStream();\n    \n    if (src instanceof MediaStream) {\n        src.getAudioTracks().forEach(track => stream.addTrack(track));\n    }\n    else if (src instanceof MediaStreamTrack) {\n        stream.addTrack(src);\n    }\n    // else throw new Error();\n\n    return stream;\n};\n\nexport default class AudioObject {\n    constructor({\n        id,\n        source = null,\n        sourceType = \"stream\",\n        context,\n        destination,\n        mediaType,\n        muted,\n    }) {\n        this._id = id;\n        this._source = source;\n        this._sourceType = sourceType;\n        // this._source = convertAudioStream(source);\n        this._audioCtx = context;\n        this._destination = destination;\n\n        this._mediaType = mediaType;\n        this._muted = muted;\n\n        // this._filteredNode = this._audioCtx.createGain();\n        // this._filteredNode.gain.value = 1.0;\n        if(this._sourceType === \"stream\") {\n            this._sourceNode = this._audioCtx.createMediaStreamSource(this._source);\n        } else {\n            this._sourceNode = this._audioCtx.createMediaElementSource(this._source);\n        }\n\n        this._gainNode = this._audioCtx.createGain();\n\n        if (mediaType === \"mycam\") {\n            this._gainNode.gain.value = 0.5;\n            // voice bandpass filter\n            const filter = this._audioCtx.createBiquadFilter()\n            var geometricMean = Math.sqrt(300 * 3400);\n            filter.frequency.value = geometricMean;\n            filter.Q.value = geometricMean / (300 - 3400);\n\n            // if mic node is source then -> filter -> gain -> dest\n            this._sourceNode.connect(filter);\n            filter.connect(this._gainNode);\n        } else {\n            this._gainNode.gain.value = 1.0;\n            // if mic node is not source then -> gain -> dest\n            this._sourceNode.connect(this._gainNode);\n        }\n\n        this._gainNode.connect(this._destination);\n\n\n        // this._audio.play();\n        // console.log(this._destination)\n\n        // this._gainNode = this._audioCtx.createGain();\n        // this._gainNode.gain.value = 1.0;\n\n        // this._sourceNode.connect(this._gainNode);\n// console.log(\"audio type\", type)\n//         if (type === \"mic\") {\n//             const lowpassFilterNode = this._audioCtx.createBiquadFilter();\n//             lowpassFilterNode.type = 'lowpass';\n//             lowpassFilterNode.frequency.setValueAtTime(100, this._audioCtx.currentTime);\n\n//             const highpassFilterNode = this._audioCtx.createBiquadFilter();\n//             highpassFilterNode.type = 'highpass';\n//             highpassFilterNode.frequency.setValueAtTime(1500, this._audioCtx.currentTime);\n\n//             this._gainNode.connect(lowpassFilterNode);\n//             lowpassFilterNode.connect(highpassFilterNode);\n//             highpassFilterNode.connect(this._filteredNode);\n//         } else {\n//             this._gainNode.connect(this._filteredNode)\n//         }\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    disconnect() {\n        this._gainNode.disconnect();\n        this._sourceNode.disconnect();\n    }\n\n    mute(value) {\n        if(value) {\n            this._gainNode.gain.setValueAtTime(0, this._audioCtx.currentTime);\n        } else {\n            // this._sourceNode.connect(this._gainNode);\n            // this._gainNode.connect(this._destination);\n\n            // if (this._mediaType === \"mic\") {\n            //     this._gainNode.gain.setValueAtTime(0.5, this._audioCtx.currentTime);\n            // } else {\n            //     this._gainNode.gain.setValueAtTime(1.0, this._audioCtx.currentTime);\n            // }\n            this._gainNode.gain.setValueAtTime(1.0, this._audioCtx.currentTime);\n        }\n    }\n\n    setVolume(value) {\n        this._gainNode.gain.setValueAtTime(value, this._audioCtx.currentTime);\n    }\n\n}","import AudioObject, { convertAudioStream } from \"./AudioObject\";\n\n\nconst setVolume = ({ node, volume }) => {\n    const _volume = parseInt(volume, 10) / 100;\n    if (_volume < 0 || _volume > 1) throw new Error('volume scope exceed');\n    if (!node) throw new Error('node is null');\n\n    // eslint-disable-next-line no-param-reassign\n    node.gain.value = _volume;\n};\n\nconst getVolume = node => {\n    return node.gain.value;\n};\n\nexport default class AudioMixer {\n    constructor() {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        \n        this.audioCtx = new AudioContext();\n        this.destination = this.audioCtx.createMediaStreamDestination();\n        this._isEnable = true;\n        this.audioObjectList = [];\n\n        this.addNoiseOscillator();\n    }\n\n    addNoiseOscillator() {\n        const oscillator = this.audioCtx.createOscillator();\n        oscillator.type = 'sine';\n        oscillator.frequency.setValueAtTime(24000, this.audioCtx.currentTime); // value in hertz\n        oscillator.connect(this.destination);\n        oscillator.start();\n    }\n\n    getContext() {\n        return this.audioCtx;\n    }\n\n    getDestination() {\n        return this.destination;\n    }\n\n    getMasterNode() {\n        return this.masterNode;\n    }\n    \n\n    addAudioObject(aObj) {\n        this.audioObjectList.push(\n            aObj\n        )\n    }\n\n    removeAudioObject(id) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        if(idx === -1) return;\n        const aObj = this.audioObjectList[idx];\n        aObj.disconnect();\n        this.audioObjectList.splice(idx, 1)\n    }\n\n    getAudioTracks() {\n        return this.destination.stream.getTracks();\n    }\n \n    mute(id, value) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        const aObj = this.audioObjectList[idx];\n        aObj.mute(value);\n    }\n\n    setVolume(id, value) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        const aObj = this.audioObjectList[idx];\n        aObj.setVolume(value)\n    }\n}\n","export const SCREEN = {\n    width: 1280,\n    height: 720,\n    // width: 640,\n    // height: 360\n}\n\nconst MARGIN = {\n    TOP: 10,\n    LEFT: 10,\n    RIGHT: 10,\n    BOTTOM: 10\n}\n\nexport const SIZE = {\n    SMALL: {\n        WIDTH: SCREEN.width / 4,\n        HEIGHT: SCREEN.height / 4\n    }\n}\n\nexport const PRESET_POSITION = {\n    FULL: {\n        top: 0,\n        left: 0,\n        width: SCREEN.width,\n        height: SCREEN.height\n    },\n    LEFT_FULL: {\n        top: 0,\n        left: 0,\n        width: SCREEN.width / 2,\n        height: SCREEN.height\n    },\n    RIGHT_FULL: {\n        top: 0,\n        left: SCREEN.width / 2,\n        width: SCREEN.width / 2,\n        height: SCREEN.height\n    },\n    TOP_LEFT_SMALL: {\n        top: MARGIN.TOP,\n        left: MARGIN.LEFT,\n        ...SIZE.SMALL\n    },\n    TOP_RIGHT_SMALL: {\n        top: MARGIN.TOP,\n        left: getHorizontalRight(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    TOP_CENTER_SMALL: {\n        top: MARGIN.TOP,\n        left: getHorizontalCenter(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    BOTTOM_LEFT_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: MARGIN.LEFT,\n        ...SIZE.SMALL\n    },\n    BOTTOM_RIGHT_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: getHorizontalRight(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    BOTTOM_CENTER_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: getHorizontalCenter(SIZE.SMALL.HEIGHT),\n        ...SIZE.SMALL\n    }\n}\n\nfunction getHorizontalRight(objWidth) {\n    return SCREEN.width - objWidth - MARGIN.RIGHT;\n}\n\nfunction getHorizontalCenter(objWidth) {\n    return (SCREEN.width / 2) - (objWidth / 2);\n}\n\nfunction getVerticalBottom(objHeight) {\n    return SCREEN.height - objHeight - MARGIN.BOTTOM;\n}\n\nfunction getVerticalCenter(objHeight) {\n    return (SCREEN.height / 2) - (objHeight / 2);\n}","import Debugger from '../StreamMixer.Debugger';\n// import VideoObject from './VideoObject';\n\n// import { WORKER_MESSAGE_TYPE } from './workers/VideoMixerWorker';\n\nimport { SCREEN } from './preset/POSITIONS';\n\nexport const EXT_WORKER_MESSAGE_TYPE = {\n    PUT_OFFSCREEN: \"PUT_OFFSCREEN\"\n}\n\nconst FRAMES_PER_SECOND = 20;\n// requesetAnimFrame용\nconst FRAME_MIN_TIME = (1000 / 60) * (60 / FRAMES_PER_SECOND) - (1000 / 60) * 0.5;\n// same\nconst INTERVAL = 1000 / FRAMES_PER_SECOND;\nconst MAX_FRAME_TIME = 1000 / FRAMES_PER_SECOND;\nconst MIN_FRAME_TIME = 20;\n// 16.666666666666667 * 2 - 16.666666666666667 * 0.5 = 25\n// const _drawInterval = parseInt(1000 / FRAMES_PER_SECOND);\nlet lastDrawTime = 0;\nlet lastFrameTime = 0;\n\n// 객체 grid 관련\nconst SIZE = {\n    MIN_WIDTH: 370,\n    MIN_HEIGHT: 208\n}\n\nconst GUIDE = {\n    POINT_SIZE: 40,\n    LINE_WIDTH: 4,\n    LINE_COLOR: \"rgba(0,184,152,1)\", // \"#F81894\"; hotpink\n    Z_INDEX_BUTTON_WIDTH: 80,\n    Z_INDEX_BUTTON_HEIGHT: 60,\n    Z_INDEX_BUTTON_COLOR: \"rgba(0,184,152,.75)\",\n    Z_INDEX_BUTTON_COLOR_UP: \"rgba(0,184,152,.85)\",\n    Z_INDEX_BUTTON_COLOR_DOWN: \"rgba(0,184,152,.5)\",\n    Z_INDEX_TEXT_FONT: \"48px Arial\",\n    Z_INDEX_TEXT_FONT_SIZE: 48,\n    Z_INDEX_TEXT_WIDTH: 80,\n    Z_INDEX_TEXT_HEIGHT: 80,\n    ARROW_WIDTH: 28,\n    ARROW_HEIGHT: 28,\n    ARROW_COLOR: \"#222222\"\n}\n\n// 마우스 버튼 custom constraint\n// (event.button의 상태가 non-click, click이 둘다 0이기 떄문에 non-click = -1, click = 0으로 지정)\nconst MOUSE_BUTTON = {\n    NONE: -1,\n    CLICKED: 0\n}\n\nconst SETTINGS = {\n    Z_INDEX_MIN: 1,\n    Z_INDEX_MAX: 9\n}\nexport default class VideoMixer {\n    constructor(canvasElementID, previewVideoElementID) {\n        this.videoObjectList = [];\n        this.videoObjectListAsc = [];\n        this.optimizeDrawMode = false;\n\n        this.mouseButtonState = MOUSE_BUTTON.NONE;\n\n        this.initCanvas(canvasElementID);\n\n        // vertical , horizontal 캔버스가 화면에 1:1로 보여주는게 아니기 떄문에 마우스 좌표에 ratio값을 곱해줘야함\n        this.vRatio = SCREEN.width / this.uiCanvas.offsetWidth;\n        this.hRatio = SCREEN.height / this.uiCanvas.offsetHeight;\n\n        this.bindEventHandler();\n\n        this.requestAnimStartTime = 0;\n        this.recursiveStartTime = performance.now();\n\n        this.now = 0;\n        this.then = Date.now();\n        this.delta = 0;\n        // document.body.appendChild(emptyCanvas)\n    }\n\n    initCanvas(canvasElementID) {\n        // init uiCanvas\n        this.uiCanvas = document.querySelector(`#${canvasElementID}`);\n        this.uiCanvasCtx = this.uiCanvas.getContext(\"2d\", { desynchronized: true, alpha: false });\n        this.uiCanvas.width = SCREEN.width;\n        this.uiCanvas.height = SCREEN.height;\n\n        // init frontCanvas\n        this.frontCanvas = document.createElement('canvas');\n        this.frontCanvas.width = SCREEN.width;\n        this.frontCanvas.height = SCREEN.height;\n        this.frontCanvasCtx = this.frontCanvas.getContext(\"2d\", { desynchronized: true, alpha: false });\n        // init backbufferCanvas\n        // firefox에서 OffscreenCanvas가 지원되지 않음 (2019-11-19 기만)\n        // OffscreenCanvas가 없으면 frontCanvas에 직접 그림\n        if (typeof OffscreenCanvas !== \"undefined\") {\n            this.bufferCanvas = new OffscreenCanvas(SCREEN.width, SCREEN.height);\n            this.bufferCanvasCtx = this.bufferCanvas.getContext(\"2d\", { desynchronized: true, alpha: false });\n        } else {\n            this.bufferCanvas = this.frontCanvas;\n            this.bufferCanvasCtx = this.frontCanvasCtx;\n        }\n        // this.canvasCtx.fillStyle = 'black';\n        // this.canvasCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // issue: captureStream parameter로 프레임을 지정시 오히려 캡쳐가 끊기는 현상이 있음\n        // 일단은 parameter를 비우고 진행 (2019.11.4 기만)\n        this.mixedStream = this.frontCanvas.captureStream();\n    }\n\n\n    // attachMainWorker(workerInstance) {\n    //     this._mainWorker = workerInstance;\n    //     this._mainWorker.postMessage({\n    //         type: WORKER_MESSAGE_TYPE.ATTACH_CANVAS,\n    //         maincanvas: this.transferControl\n    //     }, [this.transferControl])\n\n    //     // this._mainWorker.onmessage = function(e) {\n    //     //     switch(e.data.type) {\n    //     //         case WORKER_MESSAGE_TYPE.PUT_OFFSCREEN:\n    //     //             const offscreenCtx = e.data.offscreen.getContext(\"2d\");\n        \n    //     //             const imageData = offscreenCtx.getImageData(0,0,offscreenCtx.width, offscreenCtx.height);\n        \n    //     //             this.canvasCtx.putImageData(imageData, 0, 0)\n    //     //             break;\n    //     //     }\n    //     // }\n    // }\n\n    enableCanvas(id, value) {\n        const idx = this.videoObjectList.findIndex(d => d.id === id);\n        const vObj = this.videoObjectList[idx];\n        vObj.setEnable(value)\n    }\n\n    getVideoObject(id) {\n        const idx = this.videoObjectList.findIndex(d => d.id === id);\n        const vObj = this.videoObjectList[idx];\n        return vObj;\n    }\n\n    addVideoObject(vObj) {\n        this.videoObjectList.push(vObj);\n        this.sortVideoObjectList();\n        // console.log(videoObject)\n        // clearTimeout(this._drawTimeoutHandler);\n        \n        // this.drawWithWorker(this.videoObjectList);\n\n        // const workerObject = {\n            // id: videoObject.id,\n            // top: videoObject.top,\n            // left: videoObject.left,\n            // width: videoObject.width,\n            // height: videoObject.height,\n            // zIndex: videoObject.zIndex,\n            // fillMode: videoObject.fillMode,\n            // transparent: videoObject.transparent,\n            // offscreen: videoObject.getOffscreenCanvas()\n        // }\n        // console.log(workerObject)\n        // this._mainWorker.postMessage({\n        //     TYPE: WORKER_MESSAGE_TYPE.ADD_OBJECT,\n        //     object: workerObject,\n        // });\n    }\n\n    removeVideoObject(id) {\n        const idx = this.videoObjectList.findIndex( val => val.id === id );\n        this.videoObjectList.splice(idx, 1);\n        const ascIdx = this.videoObjectListAsc.findIndex( val => val.id === id);\n        this.videoObjectListAsc.splice(ascIdx, 1);\n        this.detachEventObject();\n    }\n\n    setDrawMode(val) {\n        this.optimizeDrawMode = val;\n    }\n\n    draw(time) {\n        if(time - lastDrawTime < MAX_FRAME_TIME) {\n            // this.draw(performance.now());\n            window.requestAnimationFrame(this.draw.bind(this));\n            return;\n        }\n        lastDrawTime = time;\n\n        // clear & fill black background\n        // perfomance test clearRect() vs fillRect()\n        // https://stackoverflow.com/a/30830253\n        // (test-code : https://jsperf.com/canvas-fill-vs-clear)\n        this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n        this.bufferCanvasCtx.fillStyle = \"black\";\n        this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n        // draw video objects (order zIndex)\n        this.videoObjectList.map( vObj => {\n            const drawSource = vObj.getDrawSource();\n            if (!drawSource) return;\n            const { src } = drawSource;\n \n            // drawImage의 방법 세가지중 이방법은 최적화의 좋지 않아 구조 변경함.\n            // drawImage의 첫번째 메소드(3파라미터)를 쓰는게 최적화 방법에 제일 좋다고함 (2019-12-12 기만)\n            // this.canvasCtx.drawImage(\n            //     src,\n            //     0,\n            //     0,\n            //     srcWidth,\n            //     srcHeight,\n            //     vObj.drawLeft,\n            //     vObj.drawTop,\n            //     vObj.drawWidth,\n            //     vObj.drawHeight\n            // )\n            this.bufferCanvasCtx.drawImage(\n                src,\n                vObj.left,\n                vObj.top\n            )\n        })\n\n        // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n        if (typeof (OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n\n        // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n        this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n        if (this.mouseOverObject) {\n            if (!this.mouseOverObject.isFullscreen()) {\n                this.drawOutline();\n                this.drawTriangle();\n            }\n            this.drawZIndexButton();\n        }\n        // this.mixedStream.getVideoTracks()[0].requestFrame();\n     \n        // this.draw(performance.now())\n        // setTimeout(this.draw.bind(this), 10, performance.now())\n        window.requestAnimationFrame(this.draw.bind(this));\n    }\n\n    drawCalcDeltaTime() {\n        window.requestAnimationFrame(this.drawCalcDeltaTime.bind(this))\n        this.now = Date.now();\n        this.delta = this.now - this.then;\n\n        if(this.delta > INTERVAL) {\n            this.then = this.now - (this.delta % INTERVAL);\n\n            // clear & fill black background\n            // perfomance test clearRect() vs fillRect()\n            // https://stackoverflow.com/a/30830253\n            // (test-code : https://jsperf.com/canvas-fill-vs-clear)\n            this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n            this.bufferCanvasCtx.fillStyle = \"black\";\n            this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n    \n            // draw video objects (order zIndex)\n            this.videoObjectList.map( vObj => {\n                const drawSource = vObj.getDrawSource();\n                if (!drawSource) return;\n                const { src } = drawSource;\n     \n                // drawImage의 방법 세가지중 이방법은 최적화의 좋지 않아 구조 변경함.\n                // drawImage의 첫번째 메소드(3파라미터)를 쓰는게 최적화 방법에 제일 좋다고함 (2019-12-12 기만)\n                // this.canvasCtx.drawImage(\n                //     src,\n                //     0,\n                //     0,\n                //     srcWidth,\n                //     srcHeight,\n                //     vObj.drawLeft,\n                //     vObj.drawTop,\n                //     vObj.drawWidth,\n                //     vObj.drawHeight\n                // )\n                this.bufferCanvasCtx.drawImage(\n                    src,\n                    vObj.left,\n                    vObj.top\n                )\n            })\n    \n            // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n            if (typeof (OffscreenCanvas))\n                this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n    \n            // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n            this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n            if (this.mouseOverObject) {\n                if (!this.mouseOverObject.isFullscreen()) {\n                    this.drawOutline();\n                    this.drawTriangle();\n                }\n                this.drawZIndexButton();\n            }\n        }\n        // this.mixedStream.getVideoTracks()[0].requestFrame();\n     \n        // this.draw(performance.now())\n        // setTimeout(this.draw.bind(this), 10, performance.now())\n    }\n\n    drawWithFps() {\n        this.startTime = Date.now();\n        // this.mixedStream.getVideoTracks()[0].requestFrame();\n        // console.log(\"실제:\",this.startTime)\n        // clear & fill black background\n        this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n        this.bufferCanvasCtx.fillStyle = \"black\";\n        this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n        // draw video objects (order zIndex)\n        this.videoObjectList.map( vObj => {\n            const drawSource = vObj.getDrawSource();\n            if (!drawSource) return;\n            const { src } = drawSource;\n\n            this.bufferCanvasCtx.drawImage(\n                src,\n                vObj.left,\n                vObj.top\n            )\n        })\n\n        // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n        if (typeof (OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n\n        // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n        this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n        if (this.mouseOverObject) {\n            if (!this.mouseOverObject.isFullscreen()) {\n                this.drawOutline();\n                this.drawTriangle();\n            }\n            this.drawZIndexButton();\n        }\n\n        this.mixedStream.getVideoTracks()[0].requestFrame();\n        \n        this.executeTime = Date.now() - this.startTime;\n        this.nextFrameDelay = MAX_FRAME_TIME - this.executeTime;\n        if(this.nextFrameDelay <= MIN_FRAME_TIME) {\n            this.nextFrameDelay = MIN_FRAME_TIME;\n            Debugger.DroppedFrames.increase();\n        }\n        Debugger.Frames.setLastExecuteTime(this.executeTime);\n        Debugger.Frames.setLastFrameDelay(this.nextFrameDelay);\n        \n\n        // console.log(this.nextFrameDelay)\n        // console.log(\"예상:\", performance.now() + this.nextFrameDelay)\n        setTimeout(\n            this.drawWithFps.bind(this),\n            this.nextFrameDelay\n        )\n        // window.requestAnimationFrame(this.drawWithFps.bind(this))\n    }\n\n    sleep(milliseconds) {\n        const start = Date.now();\n        while ((Date.now() - start) < milliseconds);\n    }\n\n    drawWithoutFps(time) {\n        // clear & fill black background\n        this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n        this.bufferCanvasCtx.fillStyle = \"black\";\n        this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n        // draw video objects (order zIndex)\n        this.videoObjectList.map( vObj => {\n            const drawSource = vObj.getDrawSource();\n            if (!drawSource) return;\n            const { src } = drawSource;\n\n            this.bufferCanvasCtx.drawImage(\n                src,\n                vObj.left,\n                vObj.top\n            )\n        })\n\n        // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n        if (typeof (OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n\n        // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n        this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n        if (this.mouseOverObject) {\n            if (!this.mouseOverObject.isFullscreen()) {\n                this.drawOutline();\n                this.drawTriangle();\n            }\n            this.drawZIndexButton();\n        }\n\n        setTimeout(this.drawWithoutFps.bind(this), 20)\n    }\n\n    drawOutline() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n        ctx.strokeStyle = GUIDE.LINE_COLOR;\n        ctx.lineWidth = GUIDE.LINE_WIDTH;\n        ctx.strokeRect(\n            destObject.left + parseInt(GUIDE.LINE_WIDTH / 2),\n            destObject.top + parseInt(GUIDE.LINE_WIDTH / 2),\n            destObject.width - parseInt(GUIDE.LINE_WIDTH + 1),\n            destObject.height - parseInt(GUIDE.LINE_WIDTH + 1)\n        );\n    }\n\n    drawTriangle() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n\n        const drawTopLeft = () => {\n            ctx.beginPath();\n            // x = right, y = bottom - POINT_SIZE\n            let x = destObject.left;\n            let y = destObject.top;\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = destObject.left + GUIDE.POINT_SIZE;\n            y = destObject.top;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = destObject.left;\n            y = destObject.top + GUIDE.POINT_SIZE;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.LINE_COLOR;\n            ctx.fill();            \n        }\n        const drawBottomRight = () => {\n            ctx.beginPath();\n            // x = right, y = bottom - POINT_SIZE\n            let x = destObject.left + destObject.width;\n            let y = destObject.top + destObject.height - GUIDE.POINT_SIZE;\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = destObject.left + destObject.width;\n            y = destObject.top + destObject.height;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = destObject.left + destObject.width - GUIDE.POINT_SIZE;\n            y = destObject.top + destObject.height;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n    \n            ctx.fillStyle = GUIDE.LINE_COLOR;\n            ctx.fill();\n        }\n        drawTopLeft();\n        drawBottomRight();\n    }\n\n    drawZIndexButton() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n        let objTop = destObject.top + GUIDE.LINE_WIDTH;\n        let objRight = destObject.left + destObject.width - GUIDE.LINE_WIDTH;\n        if(destObject.isFullscreen()) {\n            objRight = SCREEN.width;\n        }\n        const drawButtonBackground = () => {\n            const drawUpButton = (color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(\n                    objRight - GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    objTop,\n                    GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                );\n            }\n\n            const drawDownButton = (color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(\n                    objRight - GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                    GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                );\n            }\n            \n            switch(this.clickPosition) {\n                case \"up-arrow\":\n                    if(this.mouseButtonState === MOUSE_BUTTON.NONE)\n                        drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR_UP);\n                    else if (this.mouseButtonState === MOUSE_BUTTON.CLICKED)\n                        drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR_DOWN);\n                    drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n                case \"down-arrow\":\n                    if (this.mouseButtonState === MOUSE_BUTTON.NONE)\n                        drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR_UP);\n                    else if (this.mouseButtonState === MOUSE_BUTTON.CLICKED)\n                        drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR_DOWN);\n                    drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n                default:\n                    drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n            }\n\n        }\n\n        const drawUpArrow = () => {\n            ctx.beginPath();\n            // x = button-center, y = arrowStart\n            let x = objRight - (GUIDE.Z_INDEX_BUTTON_WIDTH / 2);\n            let y = objTop + ((GUIDE.Z_INDEX_BUTTON_HEIGHT - GUIDE.ARROW_HEIGHT) / 2);\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = x + (GUIDE.ARROW_WIDTH / 2);\n            y = y + GUIDE.ARROW_HEIGHT;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = x - GUIDE.ARROW_WIDTH;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fill();\n        }\n\n        const drawDownArrow = () => {\n            ctx.beginPath();\n            // x = button-center, y = arrowStart\n            let x = objRight - (GUIDE.Z_INDEX_BUTTON_WIDTH / 2);\n            let y = objTop +\n                GUIDE.Z_INDEX_BUTTON_HEIGHT +\n                // GUIDE.Z_INDEX_TEXT_HEIGHT +\n                (GUIDE.Z_INDEX_BUTTON_HEIGHT / 2 + GUIDE.ARROW_HEIGHT / 2);\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = x + (GUIDE.ARROW_WIDTH / 2);\n            y = y - GUIDE.ARROW_HEIGHT;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = x - GUIDE.ARROW_WIDTH;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fill();\n        }\n\n        const drawZIndexText = () => {\n            // background\n            ctx.fillStyle = GUIDE.Z_INDEX_BUTTON_COLOR;\n            ctx.fillRect(\n                objRight - GUIDE.Z_INDEX_TEXT_WIDTH,\n                objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                GUIDE.Z_INDEX_TEXT_WIDTH,\n                GUIDE.Z_INDEX_TEXT_HEIGHT,\n            );\n            // text\n            ctx.font = GUIDE.Z_INDEX_TEXT_FONT;\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fillText(\n                destObject.zIndex,\n                objRight - (GUIDE.Z_INDEX_TEXT_WIDTH / 2),\n                objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT + (GUIDE.Z_INDEX_TEXT_HEIGHT / 2)\n            )\n        }\n\n        drawButtonBackground();\n        drawUpArrow();\n        drawDownArrow();\n        // drawZIndexText();\n    }\n\n    // 오브젝트 끝에 꼭지점 찍는 함수. 현재는 사용안함(2019-12-17. 기만)\n    // drawOutsidePoint() {\n    //     const ctx = this.canvasCtx;\n    //     const destObject = this.mouseOverObject;\n\n    //     ctx.fillStyle = GUIDE.LINE_COLOR;\n    //     // top - left\n    //     ctx.fillRect(\n    //         destObject.drawLeft,\n    //         destObject.drawTop,\n    //         GUIDE.POINT_SIZE, GUIDE.POINT_SIZE\n    //     )\n    //     // top - right\n    //     ctx.fillRect(\n    //         destObject.drawLeft + destObject.drawWidth - GUIDE.POINT_SIZE,\n    //         destObject.drawTop,\n    //         GUIDE.POINT_SIZE, GUIDE.POINT_SIZE\n    //     )\n    //     // bottom - left\n    //     ctx.fillRect(\n    //         destObject.drawLeft,\n    //         destObject.drawTop + destObject.drawHeight - GUIDE.POINT_SIZE,\n    //         GUIDE.POINT_SIZE, GUIDE.POINT_SIZE\n    //     )\n    //     // bottom - right\n    //     ctx.fillRect(\n    //         destObject.drawLeft + destObject.drawWidth - GUIDE.POINT_SIZE,\n    //         destObject.drawTop + destObject.drawHeight - GUIDE.POINT_SIZE,\n    //         GUIDE.POINT_SIZE, GUIDE.POINT_SIZE\n    //     )\n    // }\n\n    // captureStream을 Manual하게 제어하는 함수.\n    // mixedStream의 captureStream(0) 으로 세팅해놔야 requestFrame()이 동작함.\n    captureFrame(time) {\n        if (time - lastFrameTime < FRAME_MIN_TIME) { //skip the frame if the call is too early\n            window.requestAnimationFrame(this.captureFrame.bind(this));\n            return; // return as there is nothing to do\n        }\n        lastFrameTime = time; // remember the time of the rendered frame\n        // OffscreenCanvas가 있으면 frontCanvas로 전체 이미지를 copy하는 과정이 필요\n        // 현재 Chrome에만 OffscreenCanvas가 지원되기 떄문에 검증작업 필요(2019-11-20 기만)\n        if(typeof(OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.canvas, 0, 0);\n        this.mixedStream.getVideoTracks()[0].requestFrame();\n        window.requestAnimationFrame(this.captureFrame.bind(this))\n    }\n\n\n    // drawWithWorker(vObjList) {\n    //     vObjList.map(vObj => {\n    //         // console.log(vObj)\n    //         const sT = performance.now();\n    //         const imageData = vObj.getImageData();\n    //         const eT = performance.now();\n    //         // console.log(eT - sT)\n    //         if (!imageData) return;\n    //         this._mainWorker.postMessage({\n    //             type: WORKER_MESSAGE_TYPE.DRAW_IMAGE,\n    //             imageData: imageData,\n    //             left: vObj.left,\n    //             top: vObj.top,\n    //             width: vObj.width,\n    //             height: vObj.height,\n    //             fillMode: vObj.fillMode,\n    //             transparent: vObj.transparent,\n    //         })\n    //     })\n\n    //     this._mainWorker.postMessage({ type: WORKER_MESSAGE_TYPE.DRAW_MAIN_CANVAS })\n    //     // console.log(eT-sT)\n    //     this._drawTimeoutHandler = setTimeout(this.draw.bind(this), _intervalDraw, vObjList)\n    // }\n\n    // addAudioTrack(track) {\n    //     this.mixedStream.addTrack(track)\n    // }\n\n    getVideoTracks() {\n        return this.mixedStream.getVideoTracks();\n    }\n\n    // getMixedStream() { \n    //     return this.mixedStream;\n    // }\n\n    // getTracks() {\n    //     return this.mixedStream.getTracks();\n    // }\n\n    sortVideoObjectList() {\n        this.videoObjectList.sort(function (a, b) {\n            if (a.zIndex < b.zIndex) {\n                return -1;\n            } else if (a.zIndex > b.zIndex) {\n                return 1;\n            } else {\n                if(a.createdAt < b.createdAt) {\n                    return -1;\n                } else if(a.createdAt > b.createdAt) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        })\n        this.videoObjectListAsc = [];\n        for (let i = this.videoObjectList.length - 1; i >= 0; i--) {\n            this.videoObjectListAsc.push(this.videoObjectList[i])\n        }\n        // console.log(this.videoObjectList)\n        // console.log(this.videoObjectListAsc)\n    }\n\n    // getThumbnail(mime = 'image/png', quality=100) {\n    //     return new Promise((resolve, reject) => {\n    //         if(this.canvas === null) {\n    //             return reject(new Error('canvas not exists'));\n    //         }\n    //         this.canvas.toBlob(blob => resolve(blob), mime, quality);\n    //     });\n    // }\n\n    // capture(mime, quality) {\n    //     return this.getThumbnail(mime, quality);\n    // }\n\n    bindEventHandler() {\n        this.uiCanvas.ondblclick = (e) => {\n            const {clickObj, clickPosition} = this.findClickObject(e);\n            if (!clickObj) return;\n            if (clickPosition !== \"move\") return;\n            if (clickObj.isFullscreen()) {\n                // 되돌아갈 position값이 없을경우(처음부터 전체화면으로 삽입)\n                // 그럴경우 좌측 상단으로 보여줌\n                if (!clickObj.hasSavedPosition()) {\n                    clickObj.savePosition();\n                    let width = SIZE.MIN_WIDTH;\n                    let height = SIZE.MIN_HEIGHT;\n                    if(clickObj.width > clickObj.height) {\n                        const ratio = clickObj.height / clickObj.width;\n                        width = SIZE.MIN_WIDTH;\n                        height = width * ratio\n                    } else {\n                        const ratio = clickObj.width / clickObj.height;\n                        height = SIZE.MIN_HEIGHT;\n                        width = height * ratio;\n                    }\n                    clickObj.setPosition({\n                        top: 10,\n                        left: 10,\n                        width,\n                        height,\n                        zIndex: clickObj.zIndex,\n                        fullScreen: false\n                    });\n                } else {\n                    clickObj.restorePosition()\n                }\n                this.mouseOverObject = clickObj;\n            } else {\n                clickObj.savePosition();\n                let aspectRatio = clickObj.width / clickObj.height;\n                if(aspectRatio > 0) { // width > height\n                    const calcWidth = SCREEN.width;\n                    const calcHeight = SCREEN.width / aspectRatio;\n                    if(calcHeight > SCREEN.height) {\n                        clickObj.setPosition({\n                            top: 0,\n                            left: 0,\n                            width: SCREEN.height * aspectRatio,\n                            height: SCREEN.height,\n                            fullScreen: true\n                        });    \n                    } else {\n                        clickObj.setPosition({\n                            top: 0,\n                            left: 0,\n                            width: calcWidth,\n                            height: calcHeight,\n                            fullScreen: true\n                        });    \n                    }\n                } else {\n                    const calcHeight = SCREEN.height;\n                    const calcWidth = SCREEN.height * aspectRatio;\n                    clickObj.setPosition({\n                        top: 0,\n                        left: 0,\n                        width: calcWidth,\n                        height: calcHeight,\n                        fullScreen: true\n                    });\n                }\n\n                this.mouseOverObject = null;\n            }\n            this.sortVideoObjectList();\n        }\n\n        this.uiCanvas.onmousedown = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            this.mouseButtonState = e.button;\n            if(clickObj) {\n                if(clickObj.isFullscreen()) return;\n\n                this.clickObject = clickObj;\n                this.clickPosition = clickPosition;\n                this.startPos = {\n                    x: e.offsetX,\n                    y: e.offsetY\n                }\n                this.startObjectPos = {\n                    top: clickObj.top,\n                    left: clickObj.left,\n                    bottom: SCREEN.height - (clickObj.top + clickObj.height),\n                    right: SCREEN.width - (clickObj.left + clickObj.width),\n                    width: clickObj.width,\n                    height: clickObj.height,\n                    ratio: clickObj.height / clickObj.width\n                }\n            } else {\n                this.detachEventObject();\n            }\n        }\n        this.uiCanvas.onmouseover = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            this.mouseOverObject = clickObj;\n            this.clickPosition = clickPosition;\n        }\n        this.uiCanvas.onmouseout = (e) => {\n            this.detachEventObject();\n        }\n        this.uiCanvas.onmousemove = (e) => {\n            switch(this.mouseButtonState) {\n                case MOUSE_BUTTON.NONE:\n                    if(this.mouseOverObject) {\n                        this.detectMouseOut(e)\n                    }\n                    const { clickObj, clickPosition } = this.findClickObject(e);\n                    // fullscreen 모드가 아닌 오브젝트를 계속 scan\n                    if (clickObj) {\n                        this.mouseOverObject = clickObj;\n                        this.clickPosition = clickPosition;\n                        // 마우스 위치에 따라 커서 변경\n                        switch (clickPosition) {\n                            case \"up-arrow\":\n                            case \"down-arrow\":\n                                this.uiCanvas.style.cursor = \"pointer\";\n                                break;\n                            case \"move\":\n                                if(!clickObj.isFullscreen())\n                                    this.uiCanvas.style.cursor = \"move\";\n                                break;\n                            case \"top-left\":\n                            case \"bottom-right\":\n                                if (!clickObj.isFullscreen())\n                                    this.uiCanvas.style.cursor = \"nwse-resize\"; // top-left to bottom-right scale cursor\n                                break;\n                        }\n                    }\n                    break;\n                case MOUSE_BUTTON.CLICKED:\n                    if (this.clickObject) {\n                        // 커서 이동한 거리\n                        const moveX = e.offsetX - this.startPos.x;\n                        const moveY = e.offsetY - this.startPos.y;\n                        let moveX_inCanvas = this.calcUItoCanvasX(moveX);\n                        let moveY_inCanvas = this.calcUItoCanvasY(moveY)\n                        let resizeWidth = this.startObjectPos.width;\n                        let resizeHeight = resizeWidth * this.startObjectPos.ratio;\n                        switch (this.clickPosition) {\n                        case \"top-left\":\n                            moveX_inCanvas = -1 * moveX_inCanvas;\n                            resizeWidth = this.startObjectPos.width + moveX_inCanvas;\n                            resizeHeight = resizeWidth * this.startObjectPos.ratio;\n\n                            if (resizeWidth < SIZE.MIN_WIDTH) return;\n                            if (resizeHeight < SIZE.MIN_HEIGHT) return;\n\n                            // scale\n                            this.clickObject.setPosition({\n                                bottom: this.startObjectPos.bottom,\n                                right: this.startObjectPos.right,\n                                width: resizeWidth,\n                                height: resizeHeight\n                            });\n                            break;\n                        case \"bottom-right\":\n                            resizeWidth = this.startObjectPos.width + moveX_inCanvas;\n                            resizeHeight = resizeWidth * this.startObjectPos.ratio;\n\n                            if (resizeWidth < SIZE.MIN_WIDTH) return;\n                            if (resizeHeight < SIZE.MIN_HEIGHT) return;\n                            \n                            // scale\n                            this.clickObject.setPosition({\n                                top: this.startObjectPos.top,\n                                left: this.startObjectPos.left,\n                                width: resizeWidth,\n                                height: resizeHeight\n                            });\n                            break;\n                        case \"move\":\n                            if(this.clickObject.isFullscreen()) return;\n                            // console.log(e.offsetX )\n                            // console.log(this.startObjectPos.top, this.startObjectPos.left)\n                            // console.log(offsetX, offsetY)\n                            this.clickObject.left = this.startObjectPos.left + moveX_inCanvas;\n                            this.clickObject.top = this.startObjectPos.top + moveY_inCanvas\n                            break;\n                    }\n                }\n            }\n\n            // console.log(e.clientX, e.clientY, e.which);\n        }\n\n        this.uiCanvas.onmouseup = (e) => {\n            this.mouseButtonState = MOUSE_BUTTON.NONE\n        }\n\n        this.uiCanvas.onclick = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            if(clickPosition === \"up-arrow\") {\n                if(clickObj.zIndex < SETTINGS.Z_INDEX_MAX) {\n                    clickObj.zIndex = clickObj.zIndex + 1;\n                    this.sortVideoObjectList();\n                }\n            } else if(clickPosition === \"down-arrow\") {\n                if(clickObj.zIndex > SETTINGS.Z_INDEX_MIN) {\n                    clickObj.zIndex = clickObj.zIndex - 1;\n                    this.sortVideoObjectList();\n                }\n            }\n        }\n    }\n\n    calcUItoCanvasX(x) {\n        return parseInt(x * this.vRatio);\n    }\n\n    calcUItoCanvasY(y) {\n        return parseInt(y * this.hRatio);\n    }\n\n\n    // 마우스포인터가 가르치는 오브젝트 검색\n    findClickObject(e) {\n        // draw는 zIndex가 낮은순으로 하지만,\n        // object detection은 zIndex가 높은순부터 해야 제일 위의 레이어가 선택됨\n        let objList = this.videoObjectListAsc;\n        const mouseX = this.calcUItoCanvasX(e.offsetX);\n        const mouseY = this.calcUItoCanvasY(e.offsetY);\n\n        let clickPosition = \"move\";\n        const findObj = objList.find( vObj => {\n            let objTop = vObj.top;\n            let objLeft = vObj.left;\n            let objBottom = vObj.top + vObj.height;\n            let objRight = vObj.left + vObj.width;\n            if(vObj.isFullscreen()) {\n                objTop = 0;\n                objLeft = 0;\n                objBottom = SCREEN.height;\n                objRight = SCREEN.width;\n            }\n\n\n            // 상단 클릭(높이 조절)\n            // if (mouseY >= (objTop - 2) && mouseY <= (objTop + 2) &&\n            //     mouseX >= (objLeft + 2) && mouseX <= (objRight - 2)) {\n            //     state = \"top\";\n            //     return vObj\n            // }\n\n            // top - left\n            if (mouseY >= objTop && mouseY <= (objTop + GUIDE.POINT_SIZE) &&\n                mouseX >= objLeft && mouseX <= (objLeft + GUIDE.POINT_SIZE)) {\n                clickPosition = \"top-left\";\n                return vObj;\n            }\n\n            // bottom - right\n            if (mouseY >= (objBottom - GUIDE.POINT_SIZE) && mouseY <= objBottom &&\n                mouseX >= (objRight - GUIDE.POINT_SIZE) && mouseX <= objRight) {\n                clickPosition = \"bottom-right\";\n                return vObj;\n            }\n\n            // 우측 상단 zIndex up\n            if (mouseY >= objTop && mouseY <= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT) &&\n                mouseX >= (objRight - GUIDE.Z_INDEX_BUTTON_WIDTH) && mouseX <= objRight) {\n                clickPosition = \"up-arrow\";\n                return vObj;\n            }\n\n            // 우측 상단 zIndex down\n            if (mouseY >= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT) &&\n                mouseY <= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT * 2) &&\n                mouseX >= (objRight - GUIDE.Z_INDEX_BUTTON_WIDTH) && mouseX <= objRight) {\n                clickPosition = \"down-arrow\";\n                return vObj;\n            }\n\n            // 중앙 클릭()\n            if (mouseY >= objTop && mouseY <= objBottom &&\n                mouseX >= objLeft && mouseX <= objRight) {\n                clickPosition = \"move\";\n                return vObj;\n            }\n        })\n        return { clickObj: findObj, clickPosition }\n    }\n\n    detachEventObject() {\n        this.uiCanvas.style.cursor = null;\n        this.mouseOverObject = null;\n        this.clickObject = null;\n        this.clickPosition = null;\n        this.startPos = null;\n        this.startObjectPos = null;\n        this.mouseButtonState = MOUSE_BUTTON.NONE;\n    }\n\n    detectMouseOut(e) {\n        if(!this.mouseOverObject) return;\n        const mouseX = parseInt(e.offsetX * this.vRatio);\n        const mouseY = parseInt(e.offsetY * this.hRatio);\n        // 마우스 좌표와 범위체크\n        // console.log(mouseX, mouseY,\n        //     this.clickObject.left, this.clickObject.right, (this.clickObject.left + this.clickObject.width),\n        //     this.clickObject.top, this.clickObject.bottom, (this.clickObject.top + this.clickObject.height)\n        // )\n        if (mouseX < this.mouseOverObject.left ||\n            mouseX > this.mouseOverObject.right ||\n            mouseX > this.mouseOverObject.left + this.mouseOverObject.width ||\n            mouseY < this.mouseOverObject.top ||\n            mouseY > this.mouseOverObject.bottom ||\n            mouseY > this.mouseOverObject.top + this.mouseOverObject.height) {\n            this.uiCanvas.style.cursor = null;\n            this.mouseOverObject = null;\n        }\n    }\n\n\n    // requestAnimTest(time) {\n    //     console.log(\"time - \", time)\n    //     if(time - this.requestAnimStartTime < MAX_FRAME_TIME) {\n    //         window.requestAnimationFrame(this.requestAnimTest.bind(this));\n    //         return;\n    //     }\n    //     this.requestAnimStartTime = time;\n    //     console.log(time)\n    //     window.requestAnimationFrame(this.requestAnimTest.bind(this))\n    // }\n\n    // recursiveTest(time) {\n    //     console.log(\"time - \", time)\n    //     if(time - this.recursiveStartTime < MAX_FRAME_TIME) {\n    //         this.recursiveTest(performance.now())\n    //         return;\n    //     }\n    //     console.log(time - this.recursiveStartTime)\n    //     this.recursiveStartTime = time;\n\n    //     // clear & fill black background\n    //     // perfomance test clearRect() vs fillRect()\n    //     // https://stackoverflow.com/a/30830253\n    //     // (test-code : https://jsperf.com/canvas-fill-vs-clear)\n    //     this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n    //     this.bufferCanvasCtx.fillStyle = \"black\";\n    //     this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n    //     // draw video objects (order zIndex)\n    //     this.videoObjectList.map( vObj => {\n    //         const drawSource = vObj.getDrawSource();\n    //         if (!drawSource) return;\n    //         const { src } = drawSource;\n \n    //         // drawImage의 방법 세가지중 이방법은 최적화의 좋지 않아 구조 변경함.\n    //         // drawImage의 첫번째 메소드(3파라미터)를 쓰는게 최적화 방법에 제일 좋다고함 (2019-12-12 기만)\n    //         // this.canvasCtx.drawImage(\n    //         //     src,\n    //         //     0,\n    //         //     0,\n    //         //     srcWidth,\n    //         //     srcHeight,\n    //         //     vObj.drawLeft,\n    //         //     vObj.drawTop,\n    //         //     vObj.drawWidth,\n    //         //     vObj.drawHeight\n    //         // )\n    //         this.bufferCanvasCtx.drawImage(\n    //             src,\n    //             vObj.left,\n    //             vObj.top\n    //         )\n    //     })\n\n    //     // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n    //     if (typeof (OffscreenCanvas))\n    //         this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n\n    //     // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n    //     this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n    //     if (this.mouseOverObject) {\n    //         if (!this.mouseOverObject.isFullscreen()) {\n    //             this.drawOutline();\n    //             this.drawTriangle();\n    //         }\n    //         this.drawZIndexButton();\n    //     }\n\n    //     this.recursiveTest(performance.now());\n    // }\n}\n","import { SCREEN } from './preset/POSITIONS';\n\nexport const EVENT_MSG = {\n    REMOVE_ME: \"REMOVE_ME\"\n}\n\nexport default class VideoObject {\n    constructor(props) {\n        const {\n            id,\n            top, left, bottom, right,\n            width = 0, height = 0,\n            zIndex = 0,\n            fullScreen = false,\n\n            frameRate = 30,\n\n            autoSize = false,\n            transparent = false,\n            onended = null,\n\n            enabled = true,\n\n            source,\n            sourceType = \"stream\",\n        } = props;\n\n        this._id = id;\n\n        this._transparent = transparent;\n        this._enabled = enabled;\n\n        this._source = source;\n        this._sourceType = sourceType;\n\n        this._top = top;\n        this._left = left;\n        this._bottom = bottom;\n        this._right = right;\n        this._width = width;\n        this._height = height;\n        this._zIndex = zIndex;\n        this._fullScreen = fullScreen;\n        this._frameRate = frameRate;\n        this._createdAt = performance.now();\n\n        if (autoSize) {\n            const wScale = width / this._source.videoWidth;\n            const ratio = this._source.videoWidth / this._source.videoHeight;\n            // console.log(this._source.videoHeight, wScale, this._source.videoHeight * wScale)\n            this._height = this._source.videoHeight * wScale;\n        }\n\n        \n        if (typeof OffscreenCanvas !== \"undefined\") {\n            this._offscreenCanvas = new OffscreenCanvas(this._width, this._height);\n        } else {\n            this._offscreenCanvas = document.createElement('canvas');\n        }\n\n        this._offscreenCanvasCtx = this._offscreenCanvas.getContext(\n            \"2d\",\n            {\n                desynchronized: true,\n                alpha: false\n            });\n\n        this.setPosition({\n            top: this._top,\n            left: this._left,\n            bottom: this._bottom,\n            right: this._right,\n            width: this._width,\n            height: this._height\n        })\n        // const size = this.calcDrawSize();\n        // this.setDrawSize(size)\n        // this.setDrawPosition(this.calcDrawPos(size))\n            \n        this.autoDraw();\n        // this._source = document.createElement('video');\n\n        // if (this._sourceType === \"url\") {\n        //     this._source.src = source;\n        //     this._source.load();\n        //     this._source.play();\n        //     this._source.crossOrigin = 'anonymous';\n        // } else {\n        //     this._source.srcObject = source;\n        //     this._source.play();\n        // }\n        // this._source.muted = true;\n        \n        // this._source.oncanplay = () => {\n        //     // const aObj = new AudioObject({ videoEl, ...props.audio });\n        //     // _audioMixer.addAudioStream(videoEl, props.audio);\n        // }\n        \n        // this._source.onloadedmetadata = (e) => {\n        //     this._source.play();\n        // };\n\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    setEnable(value) {\n        this._enabled = value;\n        if(!value) {\n            this._offscreenCanvasCtx.fillStyle = 'black';\n            this._offscreenCanvasCtx.fillRect(0, 0, this._offscreenCanvas.width, this._offscreenCanvas.height)\n        }\n    }\n\n    get enabled() {\n        return this._enabled;\n    }\n\n    // getVideoElement() {\n    //     return this._source;\n    // }\n\n    // getStream() {\n    //     if(this._sourceType === \"stream\") {\n    //         return this._source;\n    //     } else {\n    //         return this._source.captureStream(60);\n    //     }\n    // }\n    autoDraw() {\n        this.draw();\n        window.requestAnimationFrame(this.autoDraw.bind(this));\n    }\n\n    draw() {\n        if(this._fullScreen) {\n            this._offscreenCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n            this._offscreenCanvasCtx.fillStyle = \"black\";\n            this._offscreenCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n            const posCenter = parseInt((SCREEN.width - this._width) / 2);\n            const posMiddle = parseInt((SCREEN.height - this._height) / 2);\n            // console.log(posCenter, posMiddle, this._width, this._height)\n            this._offscreenCanvasCtx.drawImage(this._source, posCenter, posMiddle, this._width, this._height);\n            return;\n        }\n        this._offscreenCanvasCtx.drawImage(this._source, 0, 0, this._width, this._height);\n    }\n    \n    getDrawSource() {\n        if(!this._enabled) return;       \n        // if(this._outline) this.drawOutline()\n\n        const srcWidth = Math.max(this._source.videoWidth || 0 , this._source.width || 0);\n        const srcHeight = Math.max(this._source.videoHeight || 0, this._source.height || 0)\n        if (srcWidth !== 0 && srcHeight !== 0) {\n            return { src: this._offscreenCanvas, srcWidth, srcHeight }\n            // return { src: this._source, srcWidth, srcHeight }\n        }\n    }\n\n    // startDraw() {\n    //     this._offscreenCanvas = new OffscreenCanvas(SCREEN.width, SCREEN.height);\n    //     this._offscreenCanvasCtx = this._offscreenCanvas.getContext('2d', {desyncronized: true});\n    //     // this._offscreenCanvasCtx = this._offscreenCanvas.getContext('2d');\n    //     // this._renderingCanvas = document.createElement('canvas');\n    //     // document.body.appendChild(this._renderingCanvas)\n    //     // this._renderingCanvas.setAttribute(\n    //     //     \"style\",\n    //     //     `position: absolute; top: 100px; left: 100px; width: 1280px; height: 720px;`\n    //     // );\n    //     // this._renderingCanvas.width = 1280;\n    //     // this._renderingCanvas.height = 720;\n\n    //     this._source.oncanplay = event => {\n    //         this._offscreenCanvasCtx.width = SCREEN.width;\n    //         this._offscreenCanvasCtx.height = SCREEN.height;\n    //         this.draw(this._source, this._source.videoWidth, this._source.videoHeight)\n    //     }\n    //     // document.body.appendChild(this._source)\n    // }\n\n    // draw(src, width, height) {\n    //     this._offscreenCanvasCtx.width = width;\n    //     this._offscreenCanvasCtx.height = height;\n    //     this._offscreenCanvasCtx.drawImage(src, 0, 0);\n    //     setTimeout(this.draw.bind(this), 16, src, this._source.videoWidth, this._source.videoHeight);\n    // }\n\n    // getOffscreenCanvas() {\n    //     return this._offscreenCanvas;\n    // }\n\n\n    // getImageData() {\n    //     if (!this._source || this._source.videoWidth === 0 || this._source.videoHeight === 0) {\n    //         return null;\n    //     }\n    //     // console.log(this.id)\n    //     // this._offscreenCanvas.width = this._source.videoWidth;\n    //     // this._offscreenCanvas.height = this._source.videoHeight;\n    //     const st = performance.now();\n    //     this._offscreenCanvasCtx.drawImage(\n    //         this._source,\n    //         0,\n    //         0,\n    //         this._source.videoWidth,\n    //         this._source.videoHeight,\n    //         0,\n    //         0,\n    //         SCREEN.width,\n    //         SCREEN.height\n    //     );\n    //     const et = performance.now();\n    //     // console.log(et - st)\n    //     // this._renderingCanvas.getContext(\"2d\").drawImage(\n    //     //     this._offscreenCanvasCtx,\n    //     //     0,\n    //     //     0,\n    //     //     1280,\n    //     //     720,\n    //     //     0,\n    //     //     0,\n    //     //     1280,\n    //     //     720\n    //     // );\n    //     if(!this._offscreenCanvasCtx || this._offscreenCanvas.width === 0 || this._offscreenCanvas.height === 0) {\n    //         return null;\n    //     }\n    //     try {\n    //         // const st = performance.now();\n    //         const imageData = this._offscreenCanvasCtx.getImageData(\n    //             0,\n    //             0,\n    //             1280,\n    //             720\n    //         );\n    //         // const et = performance.now();\n    //         // console.log(\"getImageData:\", (et - st))\n    //         return imageData;\n    //     } catch(e) {\n\n    //     }\n    // }\n\n    // // async getImageBitmap() {\n    // //     // this._offscreenCanvasCtx.width = this._source.clientWidth;\n    // //     // this._offscreenCanvasCtx.height = this._source.clientHeight;\n        \n    // //     return await createImageBitmap(this._source);\n    // // }\n\n    isFullscreen() {\n        return this._fullScreen;\n    }\n\n    hasSavedPosition() {\n        return this._savedPosition\n    }\n\n    savePosition() {\n        this._oldTop = this._top;\n        this._oldLeft = this._left;\n        this._oldBottom = this._bottom;\n        this._oldRight = this._right;\n        this._oldWidth = this._width;\n        this._oldHeight = this._height;\n        this._oldZIndex = this._zIndex;\n        this._oldFullScreen = this._fullScreen;\n        this._savedPosition = true;\n    }\n\n    restorePosition() {\n        this.setPosition({\n            top: this._oldTop,\n            left: this._oldLeft,\n            bottom: this._oldBottom,\n            right: this.oldRight,\n            width: this._oldWidth,\n            height: this._oldHeight,\n            zIndex: this._oldZIndex,\n            fullScreen: this._oldFullScreen\n        });\n    }\n\n    setPosition(values) {\n        const {\n            top,\n            left,\n            bottom,\n            right,\n            width = this._width,\n            height = this._height,\n            zIndex = this.zIndex,\n            fullScreen = this._fullScreen\n        } = values;\n        this._top = bottom ? undefined : top;\n        this._left = right ? undefined : left;\n        this._bottom = top ? undefined : bottom;\n        this._right = left ? undefined : right;\n        this._width = width;\n        this._height = height;\n        this._zIndex = zIndex;\n        this._fullScreen = fullScreen;\n\n        if (bottom && !top) {\n            this._top = SCREEN.height - bottom - height;\n            this._bottom = undefined;\n        }\n\n        if (right && !left) {\n            this._left = SCREEN.width - right - width;\n            this._right = undefined;\n        }\n\n        if(this._fullScreen) {\n            this._offscreenCanvas.width = SCREEN.width;\n            this._offscreenCanvas.height = SCREEN.height;\n        } else {\n            this._offscreenCanvas.width = width;\n            this._offscreenCanvas.height = height;\n        }\n\n        this.draw();\n        // console.log(\n        //     top,\n        //     left,\n        //     bottom,\n        //     right,\n        //     width,\n        //     height,\n        // )\n        // console.log(\n        //     this._top,\n        //     this._left,\n        //     this._bottom,\n        //     this._right ,\n        //     this._width ,\n        //     this._height ,\n        //     this._zIndex,\n        // )\n\n    }\n\n\n    // autoSize() {\n    //     this._width = this._source.videoWidth;\n    //     this._height = this._source.videoHeight;\n    //     this._offscreenCanvas.width = this._source.videoWidth;\n    //     this._offscreenCanvas.height = this._source.videoHeight;\n    //     setTimeout(this.autoSize.bind(this), 100)\n    // }\n\n\n    get top() {\n        return this._top;\n    }\n\n    set top(top) {\n        this._top = top;\n    }\n\n    get left() {\n        return this._left;\n    }\n\n    set left(left) {\n        this._left = left;\n    }\n\n\n    get width() {\n        return this._width;\n    }\n\n    set width(width) {\n        this._width = width;\n        this._offscreenCanvas.width = width;\n    }\n\n    get height() {\n        return this._height;\n    }\n\n    set height(height) {\n        this._height = height;\n        this._offscreenCanvas.height = height;\n    }\n\n    get zIndex() {\n        return this._zIndex;\n    }\n\n    set zIndex(zIndex) {\n        this._zIndex = zIndex;\n    }\n\n    set outLine(onOff) {\n        this._outline = onOff;\n    }\n\n    get createdAt() {\n        return this._createdAt\n    }\n\n}\n\n/** @description src의 형태를 파악하여 스트림으로 변환합니다.\n * @history getStream => convertVideoStream\n * @param {MediaStream|MediaStreamTrack} src MediaStream or MediaStreamTrack\n * @return {MediaStream} stream\n */\nexport const convertVideoStream = src => {\n    const stream = new MediaStream();\n// console.log(src instanceof MediaStream);\n// console.log(src instanceof MediaStreamTrack)\n    if (src instanceof MediaStream) {\n        src.getVideoTracks().forEach(track => stream.addTrack(track));\n    } else if (src instanceof MediaStreamTrack && src.kind === 'video') {\n        stream.addTrack(src);\n    } else {\n        throw new Error();\n    }\n\n    return stream;\n};\n","import Debugger from './StreamMixer.Debugger';\n\nimport AudioMixer from './AudioMixer/AudioMixer';\nimport AudioObject from './AudioMixer/AudioObject';\nimport VideoMixer from './VideoMixer/VideoMixer';\nimport VideoObject from './VideoMixer/VideoObject';\n\nimport { SCREEN, PRESET_POSITION } from './VideoMixer/preset/POSITIONS'\n// import ModuleToWorkerUrl from './Utils/ModuleToWorkerUrl';\n// import { WORKER_MESSAGE_TYPE } from './VideoMixer/VideoObjectWorker';\n\nexport default (() => {\n    let _videoElementList = [];\n    let _videoMixer = null;\n    let _audioMixer = null;\n    let _previewVideoID = null;\n    let _previewVideo = null;\n    let _outputStream = null;\n\n    const init = async (canvasElementID, videoElementID) => {\n        _previewVideoID = videoElementID;\n        _videoMixer = new VideoMixer(canvasElementID, videoElementID);\n        // _videoMixer.draw(performance.now());\n        // _videoMixer.drawWithoutFps(performance.now());\n        // _videoMixer.drawWithFps();\n        _videoMixer.drawCalcDeltaTime();\n        // _videoMixer.captureFrame();\n        _audioMixer = new AudioMixer();\n\n        await initStream();\n        initPreviewVideo(_outputStream);\n        Debugger.init(_videoElementList, _videoMixer);\n    }\n\n    const initPreviewVideo = (stream) => {\n        _previewVideo = document.getElementById(_previewVideoID);\n        _previewVideo.srcObject = stream;\n        _previewVideo.play()\n    }\n\n    /** @description 미디어를 추가합니다. (Promise)\n     * @param {object} props {source, sourceType, video:{}, audio{}}\n     * source: 미디어 소스 (stream | url)\n     * string sourceType: 미디어 소스에 따라 타입 지정 (\"stream\" | \"url\")\n     * object video: 비디오 위치 및 크기 옵션\n     * object audio: 오디오 옵션\n     * @return {string} objID\n     */\n    const addMedia = (props = { source, sourceType: \"stream\", video: {}, audio: {}, onended}) => {\n        return new Promise( async (resolve, reject) => {\n            const { source, sourceType } = props;\n\n            const objID = generateID();\n\n            // 공통 비디오 객체 생성후\n            const videoEl = document.createElement('video');\n            if (sourceType === \"url\") {\n                videoEl.muted = false;\n                videoEl.autoplay = true;\n                videoEl.src = source;\n                videoEl.load();\n                if (props.video.startTime) {\n                    videoEl.currentTime = props.video.startTime;\n                }\n                // videoEl.play();\n                // videoEl.muted = true;\n                videoEl.crossOrigin = 'anonymous';\n            } else {\n                if(props.audio.mediaType === \"mycam\")\n                    videoEl.muted = true;\n                    \n                videoEl.srcObject = source;\n                if (props.video.startTime) {\n                    videoEl.currentTime = props.video.startTime;\n                }\n            }\n\n            // play 직후 cors오류가 떨어질 수 있기 때문에 promise 타입으로 체크\n            videoEl.play()\n            .then(() => {\n\n                if (sourceType === \"url\") videoEl.crossOrigin = 'anonymous';\n\n                if (props.onended) {\n                    videoEl.onended = () => {\n                        props.onended(objID);\n                    }\n                }\n\n                _videoElementList.push({\n                    id: objID,\n                    videoEl,\n                    stream: sourceType === 'stream' ? source : null\n                })\n\n                const vObj = new VideoObject({\n                    id: objID,\n                    source: videoEl,\n                    sourceType,\n                    ...props.video\n                });\n                _videoMixer.addVideoObject(vObj);\n\n                if(sourceType === \"url\") {\n                    const aObj = new AudioObject({\n                        id: objID,\n                        source: videoEl,\n                        sourceType,\n                        context: _audioMixer.getContext(),\n                        destination: _audioMixer.getDestination(),\n                        ...props.audio,\n                    })\n                    _audioMixer.addAudioObject(aObj);\n                } else {\n                    if(source.getAudioTracks && source.getAudioTracks().length !== 0) {\n                        const aObj = new AudioObject({\n                            id: objID,\n                            source: source,\n                            sourceType,\n                            context: _audioMixer.getContext(),\n                            destination: _audioMixer.getDestination(),\n                            ...props.audio,\n                        })\n                        _audioMixer.addAudioObject(aObj);\n                    }\n                }\n\n                \n                resolve({ objID })\n            })\n            .catch((e) => {\n                console.log(e.toString());\n                reject({ err: \"not play video\" })\n            });\n        })\n    }\n\n    const findVideoItem = objID => {\n        const idx = _videoElementList.findIndex(k => k.id === objID);\n        return _videoElementList[idx];\n    }\n\n    const removeMedia = objID => {\n        const idx = _videoElementList.findIndex(k => k.id === objID);\n        // console.log(_videoElementList[idx].id);\n        // console.log(_videoElementList[idx].videoEl)\n        if (idx === -1 || !_videoElementList[idx]) {\n            console.log(`[StreamMixer] %cNot Found MediaObject : ${objID}`,'background: red; color: #fff')\n            return;\n        }\n\n        _videoMixer.removeVideoObject(objID);\n        _audioMixer.removeAudioObject(objID);\n\n        if (_videoElementList[idx].videoEl)\n            _videoElementList[idx].videoEl = undefined;\n        _videoElementList.splice(idx, 1);\n    }\n\n    const changeStream = (objID, stream) => {\n        return new Promise( (resolve, reject) => {\n            let item = findVideoItem(objID);\n            if(!item) reject(\"not found mediaObject\");\n            \n            item.videoEl.srcObject = stream;\n            item.videoEl.play();\n            return resolve();\n        })\n    }\n\n    const generateID = () => {\n        return '_' + Math.random().toString(36).substr(2, 9);\n    }\n\n    const initStream = async function() {\n        const mixedStream = new MediaStream();\n\n        _videoMixer.getVideoTracks().forEach(function(track) {\n            mixedStream.addTrack(track);\n        })\n        _audioMixer.getAudioTracks().forEach(function(track) {\n            mixedStream.addTrack(track);\n        })\n        _outputStream = mixedStream;\n        // const options = {\n        //     audioBitsPerSecond : 128000,\n        //     videoBitsPerSecond : 2500000,\n        //     mimeType : 'video/webm;codecs=h264'\n        //   }\n        // const mediaRecorder = new MediaRecorder(mixedStream, options);\n        // mediaRecorder.start();\n        // _outputStream = mediaRecorder.stream;\n        // _outputStream = await initPreviewVideo(mixedStream);\n\n    }\n\n    const getStream = function() {\n        console.log(_outputStream)\n        // 비디오 믹서에 오디오 트랙 합친후 트랙으로 꺼내기\n        return _outputStream;\n    }\n\n\n    const getAudioTracks = function() {\n        return _audioMixer.getAudioTracks();\n    }\n\n    // const mute = function(value) {\n    //     _audioMixer.setMute(value);\n    // }\n    const enableCanvas = function(id, value) {\n        _videoMixer.enableCanvas(id, value)\n    }\n\n    const pause = function (objID) {\n        const videoItem = findVideoItem(objID);\n        videoItem.videoEl.pause();\n    }\n\n    const play = function(objID) {\n        const videoItem = findVideoItem(objID);\n        videoItem.videoEl.play();\n    }\n\n    const mute = function(id, value) {\n        _audioMixer.mute(id, value)\n    }\n\n    const getCurrentTime = function(id) {\n        const idx = _videoElementList.findIndex(k => k.id === id);\n        const item = _videoElementList[idx];\n        if(!item) return 0;\n        return item.videoEl.currentTime;\n    }\n\n    const setCurrentTime = function(id, time) {\n        const idx = _videoElementList.findIndex(k => k.id === id);\n        const item = _videoElementList[idx];\n        if (!item) return;\n        item.videoEl.currentTime = time;\n    }\n\n    const setPosition = function(values) {\n        const vObj = _videoMixer.getVideoObject(values.id);\n        if (!vObj) return;\n        vObj.setPosition(values)\n        _videoMixer.sortVideoObjectList();\n    }\n\n    const setDrawMode = function(val) {\n        _videoMixer.setDrawMode(val)\n    }\n\n    const setVolume = function(id, value) {\n        _audioMixer.setVolume(id, value)\n    }\n\n    return {\n        init,\n        addMedia,\n        removeMedia,\n        changeStream,\n        getStream,\n        getAudioTracks,\n        SCREEN,\n        PRESET_POSITION,\n\n        enableCanvas,\n        pause,\n        play,\n        mute,\n        setVolume,\n        getCurrentTime,\n        setCurrentTime,\n        setPosition,\n\n        setDrawMode,\n\n        Debug: {...Debugger}\n    }\n    \n})()","import StreamMixer from './StreamMixer';\n// import * as UTILS from './ARTCUtils';\n// import { getVisualiser, getCreator } from './externals';\n\nfunction _prepareNamespaceAndModule(module) {\n    return typeof window.StreamMixer === 'object'\n        ? Object.assign({}, window.StreamMixer, module)\n        : module;\n}\n\nexport default StreamMixer"],"sourceRoot":""}